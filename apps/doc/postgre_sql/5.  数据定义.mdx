---
sidebar_position: 5
title: 5. 数据定义
---

# 数据定义

##  一、表基础

创建表

```sql
CREATE TABLE my_table (
    first_column text,
    second_column integer
);
```

删除表

```sql
DROP TABLE my_table;
```

如果删除不存在的表则会报错，可以使用`DROP TABLE IF EXISTS`变体来避免错误消息，但这并非标准`SQL`

```sql
DROP TABLE IF EXISTS my_table;
```

## 二、默认值

创建表时可以为列设置默认值，如果没有设置则默认为 `null`。

默认值可以为常量也可以是表达式：

```sql
CREATE TABLE my_table (
    timestamp date DEFAULT CURRENT_TIMESTAMP,
    product_no integer DEFAULT nextval('products_product_no_seq')
);
```

:::note  

`nextval()` 函数从一个*序列对象*提供连续的值

:::

## 三、标识列

标识列是一种特殊列，它由一个隐式序列自动生成。在许多方面，标识列的行为类似于具有默认值的列。

标识列语法如下：` GENERATED ... AS IDENTITY`

```sql
CREATE TABLE my_table (
    id1 bigint GENERATED ALWAYS AS IDENTITY,
    id2 bigint GENERATED BY DEFAULT AS IDENTITY,
    ...,
);
```

:::info

`GENERATED BY DEFAULT AS IDENTITY`：用户设置的值具有优先权

`GENERATED ALWAYS AS IDENTITY`：只有在 `INSERT`  语句指定了 `OVERRIDING SYSTEM VALUE` 时，才会接受用户指定的值

:::

## [四、生成列](https://postgres.ac.cn/docs/current/ddl-generated-columns.html)

生成列是一种特殊的列，它总是根据其他列计算得出。

生成列有两种：**存储型** 和 **虚拟型**。

语法：

```sql
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54)
);
```

生成列默认是虚拟类型。使用 `VIRTUAL` 或 `STORED` 关键字可以明确选择。

## [五、约束](https://postgres.ac.cn/docs/current/ddl-constraints.html)

`SQL` 允许您在**列**和**表**上定义约束。约束让您对表中的数据拥有您想要的控制权。如果用户尝试在违反约束的列中存储数据，将引发错误。即使值来自默认值定义，此规则也适用。

#### [5.1 CHECK 约束](https://postgres.ac.cn/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS)

允许指定某一列中的值必须满足布尔（真值）表达式。

```sql
CREATE TABLE products (
    product_no integer CHECK (product_no > 0),
    # 为约束指定单独的名称。这可以使错误消息更清晰，并允许您在需要更改约束时引用它
    price numeric CONSTRAINT positive_price CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    # 没有附加到任何列的，是表约束
    CHECK (price > discounted_price AND price > 0)
);
```

#### [5.2 NOT NULL 约束](https://postgres.ac.cn/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-NOT-NULL)

指定列不得为 null 值。

```sql
CREATE TABLE products (
    product_no integer NOT NULL,
    name text CONSTRAINT products_name_not_null NOT NULL,
    price numeric CHECK (price IS NOT NULL),
);
```

#### [5.3 UNIQUE 约束](https://postgres.ac.cn/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-UNIQUE-CONSTRAINTS)

确保**列**或**一组列**中包含的数据在表中的所有行中都是唯一的。

```sql
CREATE TABLE products (
    product_no1 integer UNIQUE,
    product_no2 integer CONSTRAINT must_be_different UNIQUE,
    # 默认 null 被认为不相等，所以可以有多行的 product_no3 设置为 null，使用 NULLS NOT DISTINCT 表示 只有一行的 product_no3  null
    product_no3 integer UNIQUE NULLS NOT DISTINCT,
    a integer,
    c integer,
    name text,
    # a + c 的复合约束必须唯一
    UNIQUE (a, c),
    UNIQUE (name)
);
```

#### [5.4 主键](https://postgres.ac.cn/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-PRIMARY-KEYS)

表示**列**或**一组列**可以用作表中行的唯一标识符。这要求值既是唯一的又是 NOT NULL 的。

```sql
CREATE TABLE example (
    b integer,
    c integer,
    PRIMARY KEY (b, c)
);
CREATE TABLE example (
    a integer PRIMARY KEY,
);
```

#### [5.5 外键](https://postgres.ac.cn/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK)

FOREIGN KEY 约束指定**列**或**一组列**中的值必须匹配另一个表中出现的行中的值。

```sql
# 产品表（被引用表）
CREATE TABLE products (
	product_no interger PRIMARY KEY,
    name text
);
# 订单表（引用表）
CREATE TABLE orders (
	order_id interger PRIMARY KEY,
    product_no interger REFERENCES products (product_no),
    # 简写，不指定 products 的列，则默认使用 products 的主键
    product_no interger REFERENCES products
);
```

自引用外键：

```sql
CREATE TABLE tree (
	node_id integer PRIMARY KEY,
    parent_id integer REFERENCES tree,
    name text
);
```



#### [5.6 排斥约束](https://postgres.ac.cn/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-EXCLUSION)
